import store from 'app/store';
import controller from 'app/lib/controller';
import { METRIC_UNITS, STOCK_TURNING_METHOD, WORKSPACE_MODE } from 'app/constants';

import defaultState from '../../../store/defaultState';

export class StockTurningGenerator {
    constructor(options) {
        const defaultOptions = defaultState.widgets.rotary.stockTurning.options;
        const newOptions = { ...defaultOptions, ...options };

        let method = STOCK_TURNING_METHOD.HALF_AND_HALF_SPIRALS;

        const newStartHeight = Number((newOptions.startHeight / 2).toFixed(2));
        const newFinalHeight = Number((newOptions.finalHeight / 2).toFixed(2));
        const feedrate = newOptions.feedrate;

        // Checking for odd and even number of passes for full spiral is done later
        if ((newStartHeight - newOptions.stepdown <= newFinalHeight) && !newOptions.enableRehoming) { // check if one pass
            method = STOCK_TURNING_METHOD.HALF_AND_HALF_SPIRALS;
        } else {
            method = STOCK_TURNING_METHOD.FULL_SPIRALS; // not one pass, then use full spiral
        }

        this.options = {
            ...newOptions,
            method,
            feedrate,
            startHeight: newStartHeight,
            finalHeight: newFinalHeight
        };
    }

    generate = () => {
        const units = store.get('workspace.units');
        const safeHeight = this.getSafeZValue();

        const { feedrate, spindleRPM, enableRehoming } = this.options;

        const wcs = controller.state?.parserstate?.modal?.wcs || 'G54';

        const headerBlock = [
            '(Header)',
            '(Generated by gSender from Sienci Labs)',
            wcs,
            units === METRIC_UNITS ? 'G21 ;mm' : 'G20 ;inches',
            `G1 F${feedrate}`,
            'G90',
            `M3 S${spindleRPM}`,
            '(Header End)',
            '\n'
        ];

        const getZeroBlock = (axes) => {
            let axesZeroLine = 'G0';

            if (axes.x) {
                axesZeroLine += ' X0';
            }

            if (axes.a) {
                axesZeroLine += ' A0';
            }

            return [
                'G90',
                `G0 Z${safeHeight}`,
                axesZeroLine
            ];
        };

        const footerBlock = [
            '\n',
            '(Footer)',
            'M5 ;Turn off spindle',
            '(End of Footer)'
        ];

        const bodyBlock = this.generateLayers([], this.options.startHeight, 1);

        const arr = [
            ...headerBlock,
            ...bodyBlock,
            ...getZeroBlock({ x: true, a: !enableRehoming }),
            ...footerBlock
        ];

        // Convert to string so it can be interpreted by controller and visualizer
        const gcodeString = arr.join('\n');

        this.gcode = gcodeString;
    }

    generateLayers = (array, currentDepth, count) => {
        const { stepdown, finalHeight } = this.options;

        if (currentDepth <= finalHeight) {
            return array.flat(); //Flatten out array at the end when all subset layers have been added
        }

        const layer = this.createLayer({ depth: currentDepth > finalHeight ? currentDepth : finalHeight, count });

        array.push(layer);

        return this.generateLayers(array, currentDepth - stepdown, count + 1);
    }

    createLayer = ({ count, depth }) => {
        const { method } = this.options;

        const runSpiral = {
            [STOCK_TURNING_METHOD.HALF_AND_HALF_SPIRALS]: this.createHalfAndHalfSpiral,
            [STOCK_TURNING_METHOD.FULL_SPIRALS]: this.createFullSpiral,
        }[method];

        if (!runSpiral) {
            throw new Error('Spiral Method Not Defined');
        }

        const layer = runSpiral(depth, count);

        return [
            `(*** Layer ${count} ***)`,
            ...layer,
            `(*** End of Layer ${count} ***)`,
            '\n'
        ];
    }

    createHalfAndHalfSpiral = (depth) => {
        const { processValue } = this;
        const { finalHeight, feedrate, stockLength, stepover, stepdown, bitDiameter } = this.options;
        const safeHeight = this.getSafeZValue();
        const halfOfStockLength = (stockLength / 2).toFixed(3);
        const throttledFeedrate = (feedrate * 0.2).toFixed(3);
        const stepoverPercentage = stepover / 100;

        const currentZValue = depth > 0
            ? depth
            : this.getDefaultCurrentZValue();

        let modifiedCurrentZValue = this.getDefaultCurrentZValue();

        if (depth > 0) {
            modifiedCurrentZValue = depth - stepdown > finalHeight ? depth - stepdown : finalHeight;
        }

        const isFinalStepdown = currentZValue - stepdown <= finalHeight;

        const array = [
            /** 1 */ `G0 Z${safeHeight}`,

            /** 2 */ 'G0 X0 A0',

            /** 3 */ `G0 Z${depth} F${throttledFeedrate}`,

            /** 4 */ 'G91',

            /** 5 */
            isFinalStepdown
                ? (`G1 A${processValue(-360)} Z${(-(currentZValue - finalHeight)).toFixed(3)} F${(0.2 * 360 * feedrate / (currentZValue * 2 * Math.PI)).toFixed(3)}`)
                : '',

            /** 6 */ `G1 A${processValue(-360)}`,

            /** 7 */ `G1 X${halfOfStockLength} A${processValue((0.5 * -360 * stockLength / (stepoverPercentage * bitDiameter))).toFixed(3)} F${(360 * feedrate / (modifiedCurrentZValue * 2 * Math.PI)).toFixed(3)}`,

            /** 8 */ `G1 A${processValue(-360)}`,

            /** 9 */ 'G90',

            /** 10 */ `G0 Z${safeHeight}`,

            /** 11 */ `G0 X${stockLength} F${throttledFeedrate}`,

            /** 12 */ `G0 Z${depth} F${throttledFeedrate}`,

            /** 13 */ 'G91',

            /** 14 */
            isFinalStepdown
                ? `G1 A${processValue(360)} Z${(-(currentZValue - finalHeight)).toFixed(3)} F${(0.2 * 360 * feedrate / (currentZValue * 2 * Math.PI)).toFixed(3)}`
                : '',

            /** 15 */ `G1 A${processValue(360)}`,

            /** 16 */ `G1 X${-halfOfStockLength} A${processValue((0.5 * 360 * stockLength / (stepoverPercentage * bitDiameter))).toFixed(3)} F${(360 * feedrate / (modifiedCurrentZValue * 2 * Math.PI)).toFixed(3)}`,

            /** 17 */ `G1 A${processValue(360)}`,
        ];

        return array;
    }

    createFullSpiral = (depth, count) => {
        const { processValue } = this;
        const {
            startHeight,
            finalHeight,
            feedrate,
            stockLength,
            stepover,
            bitDiameter,
            stepdown,
            enableRehoming
        } = this.options;
        const safeHeight = this.getSafeZValue();
        const halfOfStockLength = (stockLength / 2).toFixed(3);
        const throttledFeedrate = (feedrate * 0.2).toFixed(3);
        const stepoverPercentage = stepover / 100;
        const alternateFactor = count % 2 === 0 ? 1 : -1;

        const currentZValue = depth > 0
            ? depth
            : this.getDefaultCurrentZValue();
        let modifiedCurrentZValue = this.getDefaultCurrentZValue();
        if (depth > 0) {
            modifiedCurrentZValue = depth - stepdown > finalHeight ? depth - stepdown : finalHeight;
        }

        const isFinalStepdown = currentZValue - stepdown <= finalHeight;
        const isEvenNumberOfStepdowns = Math.ceil((startHeight - finalHeight) / stepdown) % 2 === 0;
        const isFirstLayer = currentZValue === startHeight;

        const firstLayerBlock = [
            /** 1 */ `G0 Z${safeHeight}`,

            /** 2 */ 'G0 X0 A0',

            /** 3 */ `G0 Z${depth} F${throttledFeedrate}`,

            /** 3 */ 'G91',
        ];

        const continuingLayerBlock = [
            `G1 A${processValue(alternateFactor * 360)} Z${-(isFinalStepdown ? currentZValue - finalHeight : stepdown).toFixed(3)} F${(0.2 * 360 * feedrate / (currentZValue * 2 * Math.PI)).toFixed(3)}`,

            `G1 A${processValue(alternateFactor * 360)}`,

            `G1 X${-(alternateFactor * stockLength)} A${(processValue(alternateFactor * ((360 * stockLength) / (stepoverPercentage * bitDiameter)))).toFixed(3)} F${((360 * feedrate) / (modifiedCurrentZValue * 2 * Math.PI)).toFixed(3)}`,

            `G1 A${processValue(alternateFactor * 360)}`,
        ];

        const finalLayerBlock = [
            /** 4 */ 'G91',

            /** 5 */
            isFinalStepdown
                ? (`G1 A${processValue(-360)} Z${(-(currentZValue - finalHeight)).toFixed(3)} F${(0.2 * 360 * feedrate / (currentZValue * 2 * Math.PI)).toFixed(3)}`)
                : '',

            /** 6 */ `G1 A${processValue(-360)}`,

            /** 7 */ `G1 X${halfOfStockLength} A${processValue((0.5 * -360 * stockLength / (stepoverPercentage * bitDiameter))).toFixed(3)} F${(360 * feedrate / (modifiedCurrentZValue * 2 * Math.PI)).toFixed(3)}`,

            /** 8 */ `G1 A${processValue(-360)}`,

            /** 9 */ 'G90',

            /** 10 */ `G0 Z${safeHeight}`,

            /** 11 */ `G0 X${stockLength} F${throttledFeedrate}`,

            /** 12 */ `G0 Z${depth} F${throttledFeedrate}`,

            /** 13 */ 'G91',

            /** 14 */
            isFinalStepdown
                ? `G1 A${processValue(360)} Z${(-(currentZValue - finalHeight)).toFixed(3)} F${(0.2 * 360 * feedrate / (currentZValue * 2 * Math.PI)).toFixed(3)}`
                : '',

            /** 15 */ `G1 A${processValue(360)}`,

            /** 16 */ `G1 X${-halfOfStockLength} A${processValue((0.5 * 360 * stockLength / (stepoverPercentage * bitDiameter))).toFixed(3)} F${(360 * feedrate / (modifiedCurrentZValue * 2 * Math.PI)).toFixed(3)}`,

            /** 17 */ `G1 A${processValue(360)}`,
        ];

        if (isFirstLayer) {
            return [...firstLayerBlock, ...continuingLayerBlock].flat();
        }

        if (!isFirstLayer && !enableRehoming && !isEvenNumberOfStepdowns && isFinalStepdown) {
            return finalLayerBlock.flat();
        } else {
            return continuingLayerBlock.flat();
        }
    }

    getSafeZValue() {
        const { startHeight } = this.options;
        const workspaceUnits = store.get('workspace.units');
        const zVal = workspaceUnits === METRIC_UNITS ? 3 : 0.12;

        return zVal + startHeight;
    }

    getDefaultCurrentZValue() {
        const workspaceUnits = store.get('workspace.units');
        const zVal = workspaceUnits === METRIC_UNITS ? 25 : 0.98;

        return zVal;
    }

    processValue(value) {
        const workspace = store.get('workspace', { units: 'mm', mode: WORKSPACE_MODE.DEFAULT });

        const isInInches = workspace.units === 'in';
        const isInRotaryMode = workspace.mode === WORKSPACE_MODE.ROTARY;

        if (isInInches && isInRotaryMode) {
            return +((value / 25.4).toFixed(3));
        }

        return value;
    }
}
