import get from 'lodash/get';

import store from 'app/store';
import {
    METRIC_UNITS,
    SPINDLE_MODES,
    SURFACING_DWELL_DURATION,
} from 'app/constants';
import controller from 'app/lib/controller';
import defaultState from 'app/store/defaultState';

const [M3] = SPINDLE_MODES;

export default class JointerGenerator {
    constructor({ jointer, units }) {
        this.jointer = jointer;
        this.units = units;
    }

    /**
     * Main function to generate gcode for jointer operations
     */
    generate = () => {
        const defaultJointerState = get(
            defaultState,
            'workspace.widgets.jointer',
            {}
        );

        const { jointer, units, generateGcode, getSafeZValue } = this;
        const {
            depthOfCut,
            thickness,
            feedrate,
            spindleRPM,
            spindle = M3,
            shouldDwell,
            mist,
            flood,
        } = { ...defaultJointerState, ...jointer };

        // Calculate number of passes needed
        const numberOfPasses = Math.ceil(thickness / depthOfCut);

        const wcs = controller.state?.parserstate?.modal?.wcs || 'G54';
        const z = getSafeZValue();

        const dwell = shouldDwell ? [`G04 P${SURFACING_DWELL_DURATION}`] : [];
        const m7 = mist ? ['M7'] : [];
        const m8 = flood ? ['M8'] : [];

        const gcodeArr = [
            '(Header)',
            '(Generated by gSender Jointer Tool from Sienci Labs)',
            `(Number of passes: ${numberOfPasses})`,
            wcs,
            units === METRIC_UNITS ? 'G21 ;mm' : 'G20 ;inches',
            'G90',
            `${spindle} S${spindleRPM}`,
            ...dwell,
            `G0 Z${z}`,
            'G0 X0 Y0',
            ...m7,
            ...m8,
            `G1 F${feedrate}`,
            '(Header End)',
            '\n',
        ];

        // Process multiple passes based on depth of cut and thickness
        function processGcode(arr, currentDepth, passNumber, maxDepth) {
            const actualDepth = currentDepth <= maxDepth ? currentDepth : maxDepth;
            
            const gcodeLayer = generateGcode({
                depth: actualDepth,
                passNumber,
            });
            arr.push(...gcodeLayer);

            if (currentDepth >= maxDepth || passNumber >= numberOfPasses) {
                return arr;
            }

            return processGcode(arr, currentDepth + depthOfCut, passNumber + 1, maxDepth);
        }

        const processedGcode = processGcode([], depthOfCut, 1, thickness);
        gcodeArr.push(...processedGcode);

        const m9 = mist || flood ? ['M9 ;Turn off Coolant'] : [];

        gcodeArr.push(
            '(Footer)',
            ...m9,
            'M5 ;Turn off spindle',
            ...dwell,
            '(End of Footer)',
        );

        return gcodeArr.join('\n');
    };

    /**
     * Function to generate gcode array for a single pass
     * @param {number} depth - Depth value for Z axis
     * @param {number} passNumber - Pass number for tracking
     * @returns {array} - Returns the generated gcode set in an array
     */
    generateGcode = ({ depth, passNumber }) => {
        const {
            length,
            orientation,
            stepover,
            leadInOut,
        } = this.jointer;

        const safeHeight = this.getSafeZValue();
        const actualDepth = this.toFixedValue(depth * -1);

        const gcodeArr = [
            `(*** Pass ${passNumber} - Depth: ${Math.abs(actualDepth)}${this.units} ***)`,
        ];

        // Move to safe height first
        gcodeArr.push(`G0 Z${safeHeight}`);

        // Single unidirectional pass with stepover distance and lead-in/out
        if (orientation === 'X') {
            // Jointing along X-axis (edge parallel to X)
            // Start with lead-in: move to position before start
            const startX = this.toFixedValue(0 - leadInOut);
            const endX = this.toFixedValue(length + leadInOut);
            
            gcodeArr.push(`G0 X${startX} Y${this.toFixedValue(-stepover / 2)}`);
            gcodeArr.push(`G1 Z${actualDepth}`);
            gcodeArr.push(`(Lead-in to cutting start)`);
            gcodeArr.push(`G1 X0`);
            gcodeArr.push(`(Cutting edge)`);
            gcodeArr.push(`G1 X${this.toFixedValue(length)}`);
            gcodeArr.push(`(Lead-out from cutting end)`);
            gcodeArr.push(`G1 X${endX}`);
            gcodeArr.push(`G0 Z${safeHeight}`);
            // Rapid move back to start position for next pass
            gcodeArr.push(`G0 X0`);
        } else {
            // Jointing along Y-axis (edge parallel to Y)  
            // Start with lead-in: move to position before start
            const startY = this.toFixedValue(0 - leadInOut);
            const endY = this.toFixedValue(length + leadInOut);
            
            gcodeArr.push(`G0 X${this.toFixedValue(-stepover / 2)} Y${startY}`);
            gcodeArr.push(`G1 Z${actualDepth}`);
            gcodeArr.push(`(Lead-in to cutting start)`);
            gcodeArr.push(`G1 Y0`);
            gcodeArr.push(`(Cutting edge)`);
            gcodeArr.push(`G1 Y${this.toFixedValue(length)}`);
            gcodeArr.push(`(Lead-out from cutting end)`);
            gcodeArr.push(`G1 Y${endY}`);
            gcodeArr.push(`G0 Z${safeHeight}`);
            // Rapid move back to start position for next pass
            gcodeArr.push(`G0 Y0`);
        }

        gcodeArr.push(
            '(Return to origin)',
            `G0 Z${safeHeight}`,
            'G0 X0 Y0',
            `(*** End of Pass ${passNumber} ***)`,
            '\n',
        );

        return gcodeArr;
    };

    toFixedValue(value = 0, amount = 3) {
        return Number(value.toFixed(amount));
    }

    getSafeZValue() {
        const workspaceUnits = store.get('workspace.units');
        const zVal = workspaceUnits === METRIC_UNITS ? 3 : 0.12;

        return zVal;
    }
}