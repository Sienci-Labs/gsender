import get from 'lodash/get';

import store from 'app/store';
import {
    METRIC_UNITS,
    SPINDLE_MODES,
    SURFACING_DWELL_DURATION,
} from 'app/constants';
import controller from 'app/lib/controller';
import defaultState from 'app/store/defaultState';

const [M3] = SPINDLE_MODES;

export default class JointerGenerator {
    constructor({ jointer, units }) {
        this.jointer = jointer;
        this.units = units;
    }

    /**
     * Main function to generate gcode for jointer operations
     */
    generate = () => {
        const defaultJointerState = get(
            defaultState,
            'workspace.widgets.jointer',
            {}
        );

        const { jointer, units, generateGcode, getSafeZValue } = this;
        const {
            depthOfCut,
            totalDepth,
            feedrate,
            spindleRPM,
            spindle = M3,
            shouldDwell,
            mist,
            flood,
        } = { ...defaultJointerState, ...jointer };

        const wcs = controller.state?.parserstate?.modal?.wcs || 'G54';
        const z = getSafeZValue();

        const dwell = shouldDwell ? [`G04 P${SURFACING_DWELL_DURATION}`] : [];
        const m7 = mist ? ['M7'] : [];
        const m8 = flood ? ['M8'] : [];

        const gcodeArr = [
            '(Header)',
            '(Generated by gSender Jointer Tool from Sienci Labs)',
            wcs,
            units === METRIC_UNITS ? 'G21 ;mm' : 'G20 ;inches',
            'G90',
            `${spindle} S${spindleRPM}`,
            ...dwell,
            `G0 Z${z}`,
            'G0 X0 Y0',
            ...m7,
            ...m8,
            `G1 F${feedrate}`,
            '(Header End)',
            '\n',
        ];

        // Process multiple passes based on depth of cut and total depth
        function processGcode(arr, currentDepth, passNumber, totalDepth) {
            const actualDepth = currentDepth <= totalDepth ? currentDepth : totalDepth;
            
            const gcodeLayer = generateGcode({
                depth: actualDepth,
                passNumber,
            });
            arr.push(...gcodeLayer);

            if (currentDepth >= totalDepth) {
                return arr;
            }

            return processGcode(arr, currentDepth + depthOfCut, passNumber + 1, totalDepth);
        }

        const processedGcode = processGcode([], depthOfCut, 1, totalDepth);
        gcodeArr.push(...processedGcode);

        const m9 = mist || flood ? ['M9 ;Turn off Coolant'] : [];

        gcodeArr.push(
            '(Footer)',
            ...m9,
            'M5 ;Turn off spindle',
            ...dwell,
            '(End of Footer)',
        );

        return gcodeArr.join('\n');
    };

    /**
     * Function to generate gcode array for a single pass
     * @param {number} depth - Depth value for Z axis
     * @param {number} passNumber - Pass number for tracking
     * @returns {array} - Returns the generated gcode set in an array
     */
    generateGcode = ({ depth, passNumber }) => {
        const {
            length,
            orientation,
            thickness,
            numberOfPasses,
            bitDiameter,
        } = this.jointer;

        const safeHeight = this.getSafeZValue();
        const actualDepth = this.toFixedValue(depth * -1);
        
        // Calculate stepover for multiple passes across the thickness
        const stepover = numberOfPasses > 1 ? thickness / (numberOfPasses - 1) : 0;

        const gcodeArr = [
            `(*** Pass ${passNumber} - Depth: ${Math.abs(actualDepth)}${this.units} ***)`,
        ];

        // Move to safe height first
        gcodeArr.push(`G0 Z${safeHeight}`);

        // Generate passes across the thickness
        for (let pass = 0; pass < numberOfPasses; pass++) {
            const offset = pass * stepover - (thickness / 2);
            
            gcodeArr.push(`(--- Sub-pass ${pass + 1}/${numberOfPasses} ---)`);
            
            if (orientation === 'X') {
                // Jointing along X-axis (edge parallel to X)
                gcodeArr.push(`G0 X0 Y${this.toFixedValue(offset)}`);
                gcodeArr.push(`G1 Z${actualDepth}`);
                gcodeArr.push(`G1 X${this.toFixedValue(length)}`);
                gcodeArr.push(`G0 Z${safeHeight}`);
                gcodeArr.push(`G0 X0`);
            } else {
                // Jointing along Y-axis (edge parallel to Y)
                gcodeArr.push(`G0 X${this.toFixedValue(offset)} Y0`);
                gcodeArr.push(`G1 Z${actualDepth}`);
                gcodeArr.push(`G1 Y${this.toFixedValue(length)}`);
                gcodeArr.push(`G0 Z${safeHeight}`);
                gcodeArr.push(`G0 Y0`);
            }
        }

        gcodeArr.push(
            '(Return to origin)',
            `G0 Z${safeHeight}`,
            'G0 X0 Y0',
            `(*** End of Pass ${passNumber} ***)`,
            '\n',
        );

        return gcodeArr;
    };

    toFixedValue(value = 0, amount = 3) {
        return Number(value.toFixed(amount));
    }

    getSafeZValue() {
        const workspaceUnits = store.get('workspace.units');
        const zVal = workspaceUnits === METRIC_UNITS ? 3 : 0.12;

        return zVal;
    }
}