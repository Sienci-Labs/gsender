import store from 'app/store';
import reduxStore from 'app/store/redux';
import {
    METRIC_UNITS,
    STOCK_TURNING_METHOD,
    SURFACING_DWELL_DURATION,
    WORKSPACE_MODE,
} from 'app/constants';

import defaultState from '../../../store/defaultState';
import { Rotary } from 'app/features/Rotary/definitions';

type StockTurningGeneratorOptions = Rotary['stockTurning']['options'] & {
    method?: string;
};

export class StockTurningGenerator {
    options: StockTurningGeneratorOptions;
    gcode: string;

    constructor(options: StockTurningGeneratorOptions) {
        const defaultOptions = defaultState.widgets.rotary.stockTurning.options;
        const newOptions = { ...defaultOptions, ...options };

        let method = STOCK_TURNING_METHOD.HALF_AND_HALF_SPIRALS;

        const newStartHeight = Number((newOptions.startHeight / 2).toFixed(2));
        const newFinalHeight = Number((newOptions.finalHeight / 2).toFixed(2));

        // Checking for odd and even number of passes for full spiral is done later
        if (
            newStartHeight - newOptions.stepdown <= newFinalHeight &&
            !newOptions.enableRehoming
        ) {
            // check if one pass
            method = STOCK_TURNING_METHOD.HALF_AND_HALF_SPIRALS;
        } else {
            method = STOCK_TURNING_METHOD.FULL_SPIRALS; // not one pass, then use full spiral
        }

        this.options = {
            ...newOptions,
            method,
            startHeight: newStartHeight,
            finalHeight: newFinalHeight,
        };
    }

    generate = () => {
        const units = store.get('workspace.units');
        const safeHeight = this.getSafeZValue();

        const { feedrate, spindleRPM, enableRehoming, shouldDwell } =
            this.options;

        const wcs =
            reduxStore.getState().controller.state?.parserstate?.modal?.wcs ||
            'G54';

        const dwell = shouldDwell ? [`G04 P${SURFACING_DWELL_DURATION}`] : [];

        const headerBlock = [
            '(Header)',
            '(Generated by gSender from Sienci Labs)',
            wcs,
            units === METRIC_UNITS ? 'G21 ;mm' : 'G20 ;inches',
            `G1 F${feedrate}`,
            'G90',
            `M3 S${spindleRPM}`,
            ...dwell,
            '(Header End)',
            '\n',
        ];

        const getZeroBlock = (axes: { x: boolean; a: boolean }) => {
            let axesZeroLine = 'G0';

            if (axes.x) {
                axesZeroLine += ' X0';
            }

            if (axes.a) {
                axesZeroLine += ' A0';
            }

            return ['G90', `G0 Z${safeHeight}`, axesZeroLine];
        };

        const footerBlock = [
            '\n',
            '(Footer)',
            'M5 ;Turn off spindle',
            '(End of Footer)',
        ];

        const bodyBlock = this.generateLayers([], this.options.startHeight, 1);

        const arr = [
            ...headerBlock,
            ...bodyBlock,
            ...getZeroBlock({ x: true, a: !enableRehoming }),
            ...footerBlock,
        ];

        // Convert to string so it can be interpreted by controller and visualizer
        const gcodeString = arr.join('\n');

        this.gcode = gcodeString;

        return gcodeString;
    };

    generateLayers = (
        array: string[][],
        currentDepth: number,
        count: number,
    ): string[] => {
        const { stepdown, finalHeight } = this.options;

        if (currentDepth <= finalHeight) {
            return array.flat(); //Flatten out array at the end when all subset layers have been added
        }

        const layer = this.createLayer({
            depth: currentDepth > finalHeight ? currentDepth : finalHeight,
            count,
        });

        array.push(layer);

        return this.generateLayers(array, currentDepth - stepdown, count + 1);
    };

    createLayer = ({ count, depth }: { count: number; depth: number }) => {
        const { method } = this.options;

        const runSpiral = {
            [STOCK_TURNING_METHOD.HALF_AND_HALF_SPIRALS]:
                this.createHalfAndHalfSpiral,
            [STOCK_TURNING_METHOD.FULL_SPIRALS]: this.createFullSpiral,
        }[method];

        if (!runSpiral) {
            throw new Error('Spiral Method Not Defined');
        }

        const layer = runSpiral(depth, count);

        return [
            `(*** Layer ${count} ***)`,
            ...layer,
            `(*** End of Layer ${count} ***)`,
            '\n',
        ];
    };

    createHalfAndHalfSpiral = (depth: number) => {
        const { processValue } = this;
        const {
            finalHeight,
            feedrate,
            stockLength,
            stepover,
            stepdown,
            bitDiameter,
        } = this.options;
        const safeHeight = this.getSafeZValue();
        const halfOfStockLength = (stockLength / 2).toFixed(3);
        const throttledFeedrate = (feedrate * 0.2).toFixed(3);
        const stepoverPercentage = stepover / 100;

        const currentZValue =
            depth > 0 ? depth : this.getDefaultCurrentZValue();

        let modifiedCurrentZValue = this.getDefaultCurrentZValue();

        if (depth > 0) {
            modifiedCurrentZValue =
                depth - stepdown > finalHeight ? depth - stepdown : finalHeight;
        }

        const isFinalStepdown = currentZValue - stepdown <= finalHeight;

        const array = [
            /** 1 */ `G0 Z${safeHeight}`,

            /** 2 */ 'G0 X0 A0',

            /** 3 */ `G0 Z${depth} F${throttledFeedrate}`,

            /** 4 */ 'G91',

            /** 5 */
            isFinalStepdown
                ? `G1 A${processValue(-360)} Z${(-(currentZValue - finalHeight)).toFixed(3)} F${((0.2 * 360 * feedrate) / (currentZValue * 2 * Math.PI)).toFixed(3)}`
                : '',

            /** 6 */ `G1 A${processValue(-360)}`,

            /** 7 */ `G1 X${halfOfStockLength} A${processValue((0.5 * -360 * stockLength) / (stepoverPercentage * bitDiameter)).toFixed(3)} F${((360 * feedrate) / (modifiedCurrentZValue * 2 * Math.PI)).toFixed(3)}`,

            /** 8 */ `G1 A${processValue(-360)}`,

            /** 9 */ 'G90',

            /** 10 */ `G0 Z${safeHeight}`,

            /** 11 */ `G0 X${stockLength} F${throttledFeedrate}`,

            /** 12 */ `G0 Z${depth} F${throttledFeedrate}`,

            /** 13 */ 'G91',

            /** 14 */
            isFinalStepdown
                ? `G1 A${processValue(360)} Z${(-(currentZValue - finalHeight)).toFixed(3)} F${((0.2 * 360 * feedrate) / (currentZValue * 2 * Math.PI)).toFixed(3)}`
                : '',

            /** 15 */ `G1 A${processValue(360)}`,

            /** 16 */ `G1 X${-halfOfStockLength} A${processValue((0.5 * 360 * stockLength) / (stepoverPercentage * bitDiameter)).toFixed(3)} F${((360 * feedrate) / (modifiedCurrentZValue * 2 * Math.PI)).toFixed(3)}`,

            /** 17 */ `G1 A${processValue(360)}`,
        ];

        return array;
    };

    createFullSpiral = (depth: number, count: number) => {
        const { processValue } = this;
        const {
            startHeight,
            finalHeight,
            feedrate,
            stockLength,
            stepover,
            bitDiameter,
            stepdown,
            enableRehoming,
        } = this.options;
        const safeHeight = this.getSafeZValue();
        const halfOfStockLength = (stockLength / 2).toFixed(3);
        const throttledFeedrate = (feedrate * 0.2).toFixed(3);
        const stepoverPercentage = stepover / 100;
        const alternateFactor = count % 2 === 0 ? 1 : -1;

        const currentZValue =
            depth > 0 ? depth : this.getDefaultCurrentZValue();
        let modifiedCurrentZValue = this.getDefaultCurrentZValue();
        if (depth > 0) {
            modifiedCurrentZValue =
                depth - stepdown > finalHeight ? depth - stepdown : finalHeight;
        }

        const isFinalStepdown = currentZValue - stepdown <= finalHeight;
        const isEvenNumberOfStepdowns =
            Math.ceil((startHeight - finalHeight) / stepdown) % 2 === 0;
        const isFirstLayer = currentZValue === startHeight;

        const firstLayerBlock = [
            /** 1 */ `G0 Z${safeHeight}`,

            /** 2 */ 'G0 X0 A0',

            /** 3 */ `G0 Z${depth} F${throttledFeedrate}`,

            /** 3 */ 'G91',
        ];

        const continuingLayerBlock = [
            `G1 A${processValue(alternateFactor * 360)} Z${-(isFinalStepdown ? currentZValue - finalHeight : stepdown).toFixed(3)} F${((0.2 * 360 * feedrate) / (currentZValue * 2 * Math.PI)).toFixed(3)}`,

            `G1 A${processValue(alternateFactor * 360)}`,

            `G1 X${-(alternateFactor * stockLength)} A${processValue(alternateFactor * ((360 * stockLength) / (stepoverPercentage * bitDiameter))).toFixed(3)} F${((360 * feedrate) / (modifiedCurrentZValue * 2 * Math.PI)).toFixed(3)}`,

            `G1 A${processValue(alternateFactor * 360)}`,
        ];

        const finalLayerBlock = [
            /** 4 */ 'G91',

            /** 5 */
            isFinalStepdown
                ? `G1 A${processValue(-360)} Z${(-(currentZValue - finalHeight)).toFixed(3)} F${((0.2 * 360 * feedrate) / (currentZValue * 2 * Math.PI)).toFixed(3)}`
                : '',

            /** 6 */ `G1 A${processValue(-360)}`,

            /** 7 */ `G1 X${halfOfStockLength} A${processValue((0.5 * -360 * stockLength) / (stepoverPercentage * bitDiameter)).toFixed(3)} F${((360 * feedrate) / (modifiedCurrentZValue * 2 * Math.PI)).toFixed(3)}`,

            /** 8 */ `G1 A${processValue(-360)}`,

            /** 9 */ 'G90',

            /** 10 */ `G0 Z${safeHeight}`,

            /** 11 */ `G0 X${stockLength} F${throttledFeedrate}`,

            /** 12 */ `G0 Z${depth} F${throttledFeedrate}`,

            /** 13 */ 'G91',

            /** 14 */
            isFinalStepdown
                ? `G1 A${processValue(360)} Z${(-(currentZValue - finalHeight)).toFixed(3)} F${((0.2 * 360 * feedrate) / (currentZValue * 2 * Math.PI)).toFixed(3)}`
                : '',

            /** 15 */ `G1 A${processValue(360)}`,

            /** 16 */ `G1 X${-halfOfStockLength} A${processValue((0.5 * 360 * stockLength) / (stepoverPercentage * bitDiameter)).toFixed(3)} F${((360 * feedrate) / (modifiedCurrentZValue * 2 * Math.PI)).toFixed(3)}`,

            /** 17 */ `G1 A${processValue(360)}`,
        ];

        if (isFirstLayer) {
            return [...firstLayerBlock, ...continuingLayerBlock].flat();
        }

        if (
            !isFirstLayer &&
            !enableRehoming &&
            !isEvenNumberOfStepdowns &&
            isFinalStepdown
        ) {
            return finalLayerBlock.flat();
        } else {
            return continuingLayerBlock.flat();
        }
    };

    getSafeZValue() {
        const { startHeight } = this.options;
        const workspaceUnits = store.get('workspace.units');
        const zVal = workspaceUnits === METRIC_UNITS ? 3 : 0.12;

        return zVal + startHeight;
    }

    getDefaultCurrentZValue() {
        const workspaceUnits = store.get('workspace.units');
        const zVal = workspaceUnits === METRIC_UNITS ? 25 : 0.98;

        return zVal;
    }

    processValue(value: number) {
        const workspace = store.get('workspace', {
            units: 'mm',
            mode: WORKSPACE_MODE.DEFAULT,
        });

        const isInInches = workspace.units === 'in';
        const isInRotaryMode = workspace.mode === WORKSPACE_MODE.ROTARY;

        if (isInInches && isInRotaryMode) {
            return +(value / 25.4).toFixed(3);
        }

        return value;
    }
}
